import { simulateTraffic } from '../domain/environment/trafficSimulator.js';
import { getMarketEvent } from '../domain/environment/marketEvents.js';
export class SimulationService {
    db;
    agents;
    activityLog;
    stagingService;
    loopInterval = null;
    isRunning = false;
    tickCount = 0;
    pendingRestocks = [];
    currentEvent = null;
    eventDuration = 0;
    constructor(db, agents, activityLog, stagingService) {
        this.db = db;
        this.agents = agents;
        this.activityLog = activityLog;
        this.stagingService = stagingService;
    }
    async runResearchPhase(category = 'Fitness') {
        console.log(`[Simulation] Starting flow for category: ${category}`);
        // Log simulation start
        await this.activityLog?.log({
            agent: 'System',
            action: 'simulation_started',
            category: 'system',
            status: 'started',
            message: `Starting simulation for category: ${category}`,
            details: { category }
        });
        // Set all agents to simulation mode
        this.agents.ceo.setMode('simulation');
        this.agents.research.setMode('simulation');
        this.agents.supplier.setMode('simulation');
        this.agents.store.setMode('simulation');
        this.agents.marketing.setMode('simulation');
        try {
            await this.db.saveLog('Simulation', 'Flow Started', 'info', { category });
        }
        catch (err) {
            console.error("Failed to log start", err);
        }
        try {
            // 1. Research
            await this.activityLog?.log({
                agent: 'Research',
                action: 'find_products',
                category: 'research',
                status: 'started',
                message: `Searching for products in ${category}`,
                details: { category }
            });
            const researchResult = await this.agents.research.findWinningProducts({ category });
            if (!researchResult || !researchResult.products || researchResult.products.length === 0) {
                console.error("[Simulation] No products found.");
                await this.db.saveLog('Simulation', 'No products found', 'error', {});
                await this.activityLog?.log({
                    agent: 'Research',
                    action: 'find_products',
                    category: 'research',
                    status: 'failed',
                    message: 'No products found in category',
                    details: { category }
                });
                return;
            }
            const productData = researchResult.products[0];
            console.log(`[Simulation] Selected Product: ${productData.name}`);
            await this.activityLog?.log({
                agent: 'Research',
                action: 'find_products',
                category: 'research',
                status: 'completed',
                entityType: 'product',
                entityId: productData.id,
                message: `Found product: ${productData.name}`,
                details: {
                    product: productData.name,
                    demandScore: productData.demandScore,
                    competitionScore: productData.competitionScore
                }
            });
            // Save initial product state to simulation database
            await this.db.saveProduct({ ...productData, price: 29.99, source: 'sim' });
            // 2. Source - REMOVED for Phase 1 Split
            // 3. Build Store - REMOVED for Phase 1 Split
            // STAGE FOR APPROVAL
            if (this.stagingService) {
                const sessionId = await this.stagingService.createSession(category, 'simulation', { trends: 'sim', research: 'sim' });
                await this.stagingService.stageItem(sessionId, {
                    itemType: 'product',
                    name: productData.name,
                    description: productData.description || `A ${category} product`,
                    rawData: productData,
                    confidenceScore: productData.demandScore || 0,
                    source: 'simulation',
                    trendEvidence: 'Generated by Research Agent'
                });
                console.log(`[Simulation] Product staged for approval: ${productData.name}`);
                await this.activityLog?.log({
                    agent: 'System',
                    action: 'stage_product',
                    category: 'system',
                    status: 'completed',
                    message: `Product staged for approval: ${productData.name}`,
                    details: { sessionId }
                });
            }
            else {
                console.warn("[Simulation] Staging service not available, skipping staging.");
            }
        }
        catch (e) {
            console.error("[Simulation] Flow failed:", e);
            await this.db.saveLog('Simulation', 'Flow Failed', 'error', e.message || e);
        }
        finally {
            // Reset all agents to live mode
            this.agents.ceo.setMode('live');
            this.agents.research.setMode('live');
            this.agents.supplier.setMode('live');
            this.agents.store.setMode('live');
            this.agents.marketing.setMode('live');
        }
    }
    async runLaunchPhase(stagedItemId) {
        console.log(`[Simulation] Launching staged item: ${stagedItemId}`);
        if (!this.stagingService) {
            throw new Error("Staging service not available");
        }
        const stagedItem = await this.stagingService.getItem(stagedItemId);
        if (!stagedItem) {
            throw new Error(`Staged item ${stagedItemId} not found`);
        }
        const productData = stagedItem.rawData;
        // Initialize Inventory
        productData.inventory = 50; // Start with 50 units
        await this.db.saveProduct({ ...productData, source: 'sim' });
        console.log(`[Simulation] Resuming flow for product: ${productData.name}`);
        // Set agents to simulation mode
        this.agents.supplier.setMode('simulation');
        this.agents.store.setMode('simulation');
        this.agents.marketing.setMode('simulation');
        try {
            // 2. Source
            await this.activityLog?.log({
                agent: 'Supplier',
                action: 'find_suppliers',
                category: 'sourcing',
                status: 'started',
                entityType: 'product',
                entityId: productData.id,
                message: `Finding suppliers for ${productData.name}`
            });
            await this.agents.supplier.findSuppliers({ product_id: productData.id });
            await this.activityLog?.log({
                agent: 'Supplier',
                action: 'find_suppliers',
                category: 'sourcing',
                status: 'completed',
                entityType: 'product',
                entityId: productData.id,
                message: `Suppliers found for ${productData.name}`
            });
            // 3. Build Store
            await this.activityLog?.log({
                agent: 'Store',
                action: 'create_page',
                category: 'store',
                status: 'started',
                entityType: 'product',
                entityId: productData.id,
                message: `Building product page for ${productData.name}`
            });
            const page = await this.agents.store.createProductPage({ product_data: productData });
            console.log(`[Simulation] Store Page Created: ${page.url}`);
            await this.activityLog?.log({
                agent: 'Store',
                action: 'create_page',
                category: 'store',
                status: 'completed',
                entityType: 'product',
                entityId: productData.id,
                message: `Product page created: ${page.url}`,
                details: { url: page.url }
            });
            // 4. Marketing
            await this.activityLog?.log({
                agent: 'Marketing',
                action: 'create_campaign',
                category: 'marketing',
                status: 'started',
                entityType: 'product',
                entityId: productData.id,
                message: `Creating ad campaign for ${productData.name}`
            });
            const campaign = await this.agents.marketing.createAdCampaign({
                platform: 'Facebook',
                budget: 100,
                product: productData.name
            });
            if (!campaign) {
                throw new Error("Campaign creation failed");
            }
            console.log(`[Simulation] Campaign Created: ${campaign.campaign_id}`);
            await this.activityLog?.log({
                agent: 'Marketing',
                action: 'create_campaign',
                category: 'marketing',
                status: 'completed',
                entityType: 'campaign',
                entityId: campaign.campaign_id,
                message: `Campaign created: ${campaign.campaign_id}`,
                details: { campaignId: campaign.campaign_id, platform: 'Facebook', budget: 100 }
            });
            // 5. Activate Campaign (Traffic will be handled by the loop)
            console.log("[Simulation] Activating Campaign...");
            await this.db.saveCampaign({
                id: campaign.campaign_id,
                platform: 'Facebook',
                product: productData.name,
                budget: 100,
                status: 'active',
                _db: 'sim'
            });
            console.log("[Simulation] Launch Phase Completed Successfully. Campaign is active.");
            await this.db.saveLog('Simulation', 'Launch Phase Completed', 'success', {
                product: productData.name,
                campaign: campaign.campaign_id
            });
        }
        catch (e) {
            console.error("[Simulation] Launch Phase failed:", e);
            await this.db.saveLog('Simulation', 'Launch Phase Failed', 'error', e.message || e);
            throw e;
        }
        finally {
            this.agents.supplier.setMode('live');
            this.agents.store.setMode('live');
            this.agents.marketing.setMode('live');
        }
    }
    async clearSimulationData() {
        console.log('[SimulationService] Clearing simulation database...');
        await this.db.clearSimulationData();
        // Reset tick count
        this.tickCount = 0;
        this.eventDuration = 0;
        this.currentEvent = null;
        this.pendingRestocks = [];
        console.log('[SimulationService] Reset tick count to 0');
        // Clear activity log
        if (this.activityLog) {
            console.log('[SimulationService] Clearing activity log...');
            try {
                const deleted = await this.activityLog.clearOldLogs(0); // Clear all logs (0 days retention)
                console.log(`[SimulationService] Cleared ${deleted} activity log entries`);
            }
            catch (error) {
                console.error('[SimulationService] Failed to clear activity log:', error);
            }
        }
        console.log('[SimulationService] Simulation database cleared');
    }
    // === Continuous Simulation Loop ===
    startLoop(intervalMs = 10000) {
        if (this.isRunning) {
            console.warn("[Simulation] Loop already running.");
            return;
        }
        console.log(`[Simulation] Starting continuous loop (Interval: ${intervalMs}ms)`);
        this.isRunning = true;
        this.loopInterval = setInterval(() => {
            this.tick().catch(err => console.error("[Simulation] Tick failed:", err));
        }, intervalMs);
    }
    stopLoop() {
        if (this.loopInterval) {
            clearInterval(this.loopInterval);
            this.loopInterval = null;
        }
        this.isRunning = false;
        console.log("[Simulation] Loop stopped.");
    }
    async tick() {
        if (!this.isRunning)
            return;
        // console.log("[Simulation] Tick..."); // Verbose
        try {
            this.tickCount++;
            // console.log(`[Simulation] Tick incremented to: ${this.tickCount}`);
            // 0. Handle Market Events
            if (this.eventDuration > 0) {
                this.eventDuration--;
                if (this.eventDuration === 0) {
                    console.log(`[Simulation] Market Event Ended: ${this.currentEvent?.name}`);
                    this.currentEvent = null;
                }
            }
            else {
                // 10% chance to start a new event if none active
                if (Math.random() < 0.1) {
                    const event = getMarketEvent();
                    if (event) {
                        this.currentEvent = event;
                        this.eventDuration = 10; // Lasts 10 ticks
                        console.log(`[Simulation] New Market Event: ${event.name} (${event.description})`);
                        await this.activityLog?.log({
                            agent: 'System',
                            action: 'market_event',
                            category: 'environment',
                            status: 'started',
                            message: `Market Event: ${event.name}`,
                            details: event
                        });
                    }
                }
            }
            // 0.5 Handle Restocks
            this.pendingRestocks.forEach(r => r.ticksRemaining--);
            const arriving = this.pendingRestocks.filter(r => r.ticksRemaining <= 0);
            this.pendingRestocks = this.pendingRestocks.filter(r => r.ticksRemaining > 0);
            for (const stock of arriving) {
                const products = await this.db.getProducts('sim');
                const p = products.find(prod => prod.id === stock.productId || prod.name === stock.productId); // Handle name vs ID mismatch if any
                if (p) {
                    p.inventory = (p.inventory || 0) + stock.quantity;
                    await this.db.saveProduct(p);
                    console.log(`[Simulation] Restock arrived: ${stock.quantity} units for ${p.name}. New Inventory: ${p.inventory}`);
                    await this.activityLog?.log({
                        agent: 'Supplier',
                        action: 'order_stock',
                        category: 'operations',
                        status: 'completed',
                        entityType: 'product',
                        entityId: p.id,
                        message: `Restock arrived: ${stock.quantity} units. Inventory: ${p.inventory}`
                    });
                }
            }
            // 1. Get Active Campaigns & Products
            const campaigns = await this.db.getCampaigns('sim');
            const activeCampaigns = campaigns.filter(c => c.status === 'active');
            if (activeCampaigns.length === 0) {
                // No active campaigns, nothing to simulate traffic for
                // But we still check for optimization cycle
                if (this.tickCount % 12 === 0) {
                    await this.runOptimizationCycle();
                }
                return;
            }
            const products = await this.db.getProducts('sim');
            // Group campaigns by product
            const productCampaigns = new Map();
            for (const camp of activeCampaigns) {
                if (!productCampaigns.has(camp.product)) {
                    productCampaigns.set(camp.product, []);
                }
                productCampaigns.get(camp.product)?.push(camp);
            }
            // 2. Simulate Traffic for each Product
            for (const [productName, camps] of productCampaigns.entries()) {
                const product = products.find(p => p.name === productName);
                if (!product)
                    continue;
                // Scale = 0.05 (approx 1/20th of a day per tick)
                // If interval is 10s, and we want 1 tick = 1 hour, we need to balance this.
                // Let's assume 1 tick = 1 hour of activity.
                const scale = 0.05;
                const trafficStats = simulateTraffic(product, camps, this.currentEvent, scale);
                if (trafficStats.totalVisitors > 0) {
                    // Check Inventory
                    let currentInventory = product.inventory || 0;
                    const potentialOrders = trafficStats.orders.length;
                    let actualOrders = 0;
                    let missedSales = 0;
                    const processedOrders = [];
                    for (const order of trafficStats.orders) {
                        if (currentInventory > 0) {
                            currentInventory--;
                            actualOrders++;
                            processedOrders.push(order);
                        }
                        else {
                            missedSales++;
                        }
                    }
                    // Update Inventory in DB
                    if (actualOrders > 0) {
                        product.inventory = currentInventory;
                        await this.db.saveProduct(product);
                    }
                    // Auto-Restock Logic (Low Stock Trigger)
                    if (currentInventory < 10 && !this.pendingRestocks.find(r => r.productId === product.id)) {
                        console.log(`[Simulation] Low stock for ${product.name} (${currentInventory}). Ordering more...`);
                        const restockQty = 50;
                        await this.agents.supplier.orderStock({ product_id: product.id, quantity: restockQty });
                        this.pendingRestocks.push({
                            productId: product.id,
                            quantity: restockQty,
                            ticksRemaining: 5 // Arrives in 5 ticks
                        });
                    }
                    console.log(`[Simulation] Tick: ${product.name} - ${trafficStats.totalVisitors} visitors, ${actualOrders} orders, ${missedSales} missed (Inv: ${currentInventory})`);
                    // Save orders
                    for (const order of processedOrders) {
                        await this.db.saveOrder({ ...order, source: 'sim' });
                    }
                    // Log if significant (orders, missed sales, or just traffic)
                    if (actualOrders > 0 || missedSales > 0 || trafficStats.totalVisitors > 0) {
                        const msg = `Tick: ${actualOrders} orders for ${product.name}. Visitors: ${trafficStats.totalVisitors}. Missed: ${missedSales}. Inventory: ${currentInventory}`;
                        await this.db.saveLog('System', 'simulate_traffic', 'info', {
                            visitors: trafficStats.totalVisitors,
                            orders: actualOrders,
                            missed: missedSales,
                            inventory: currentInventory
                        });
                        await this.activityLog?.log({
                            agent: 'System',
                            action: 'simulate_traffic',
                            category: 'operations',
                            status: 'completed',
                            entityType: 'product',
                            entityId: product.id,
                            message: msg,
                            details: {
                                visitors: trafficStats.totalVisitors,
                                orders: actualOrders,
                                missed: missedSales,
                                inventory: currentInventory
                            }
                        });
                    }
                }
            }
            // 3. Optimization Cycle (Every 12 ticks)
            if (this.tickCount % 12 === 0) {
                await this.runOptimizationCycle();
            }
        }
        catch (error) {
            console.error("[Simulation] Error in tick:", error);
        }
    }
    async runOptimizationCycle() {
        console.log("[Simulation] Running Optimization Cycle...");
        await this.db.saveLog('System', 'optimization_cycle', 'info', { message: 'Starting daily optimization cycle' });
        await this.activityLog?.log({
            agent: 'System',
            action: 'optimization_cycle',
            category: 'optimization',
            status: 'started',
            message: 'Starting daily optimization cycle'
        });
        try {
            // 1. Generate Report
            const report = await this.agents.analytics.generateReport({ period: 'daily' });
            console.log(`[Simulation] Optimization Report: Profit $${report.profit}`);
            await this.db.saveLog('Analytics', 'generate_report', 'info', { profit: report.profit, revenue: report.revenue });
            // 2. Analyze Campaigns
            if (report.campaigns && report.campaigns.length > 0) {
                for (const camp of report.campaigns) {
                    // Rule: Kill if profit < -$50 (Loss limit)
                    if (camp.profit < -50) {
                        console.log(`[Simulation] Optimization: Killing campaign ${camp.id} (Loss: $${camp.profit})`);
                        await this.agents.marketing.stopCampaign({ campaign_id: camp.id });
                        const stopMsg = `Stopped campaign ${camp.id} due to poor performance (Profit: $${camp.profit})`;
                        await this.db.saveLog('Marketing', 'stop_campaign', 'warning', { campaignId: camp.id, profit: camp.profit });
                        await this.activityLog?.log({
                            agent: 'Marketing',
                            action: 'stop_campaign',
                            category: 'optimization',
                            status: 'completed',
                            entityType: 'campaign',
                            entityId: camp.id,
                            message: stopMsg,
                            details: { profit: camp.profit, threshold: -50 }
                        });
                    }
                }
            }
        }
        catch (e) {
            console.error("[Simulation] Optimization failed:", e);
            await this.db.saveLog('System', 'optimization_cycle_failed', 'error', { error: e.message });
            await this.activityLog?.log({
                agent: 'System',
                action: 'optimization_cycle',
                category: 'optimization',
                status: 'failed',
                message: `Optimization cycle failed: ${e.message}`
            });
        }
    }
    getTickCount() {
        return this.tickCount;
    }
}
