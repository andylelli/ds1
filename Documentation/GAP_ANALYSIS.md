# Gap Analysis: Modular, YAML-Driven Architecture

This document outlines the transition from the current hardcoded/monolithic state to a fully modular, configuration-driven system.

## 1. The YAML Configuration Strategy

To answer "what can be spun up from YAML", the goal is **everything**. The code should be a generic engine; the YAML defines the specific application instance.

**Key Principle: Architectural Symmetry**
The system structure is **identical** in both Simulation and Live modes.
*   **Live Mode**: Driven by Real Events (Webhooks) -> Processed by Agents -> Actions on Real APIs.
*   **Sim Mode**: Driven by Synthetic Events (Orchestrator) -> Processed by Agents -> Actions on Mock APIs (Generative).

We propose a **5-File Configuration Structure**:

| File | Purpose | What it Controls |
| :--- | :--- | :--- |
| **1. ootstrap.yaml** | **Entry Point** | Environment mode (Live/Sim), Log levels, paths to other config files. |
| **2. infrastructure.yaml** | **Plumbing** | **Event Bus provider** (Postgres), Database connections, Server ports. |
| **3. mcp.yaml** | **Tools/IO** | **MCP Servers** (Stdio/SSE) and **Internal Adapters**. Defines *capabilities*. |
| **4. gents.yaml** | **Workers** | Which Agents to spawn, their System Prompts, Model settings, and assigned Tools (MCP Servers). |
| **5. workflows.yaml** | **Wiring** | Event Subscriptions. Who listens to what? (e.g., OrderPaid -> FulfillmentAgent). |

---

## 2. Detailed Gap Analysis

### A. Modular Bootstrapping (The Core Engine)

**Current State:**
*   src/index.ts manually imports and 
ews every class.
*   Switching modes requires code changes.

**Target State:**
*   src/index.ts is minimal and mode-agnostic:
    `	ypescript
    const config = YamlLoader.load('bootstrap.yaml');
    const container = new Container(config);
    container.boot();
    `
*   The **Container** instantiates the exact same core classes for both Sim and Live.

**Required Changes:**
1.  **YamlLoader**: A utility to read and merge the 5 YAML files.
2.  **ServiceFactory**: A class that takes a string name and returns an instance.
3.  **DependencyContainer**: Holds the singletons (Bus, Adapters) and injects them into Agents.

### B. Infrastructure & Event Bus (Postgres-Backed)

**Current State:**
*   Event Bus is either missing or hardcoded.

**Target State:**
*   **PostgresEventBus** is the single source of truth for both Live and Simulation.
*   **infrastructure.yaml** example:
    `yaml
    event_bus:
      type: "postgres"
      connection: ""
      table_name: "events"
    `

**Required Changes:**
1.  **Interface IEventBus**: Standardize publish() and subscribe().
2.  **Implementation**: Ensure PostgresEventBus is robust and can handle the load.
3.  **Factory Logic**: The Bootstrapper initializes the bus before any agents.

### C. MCP & Tools (Generative Mocks)

**Current State:**
*   Adapters are injected directly into Agents.

**Target State:**
*   **Live Mode**: Adapters wrap real API calls (Shopify, Meta).
*   **Sim Mode**: Adapters are **Generative Mocks**.
    *   They do NOT just return static data.
    *   They generate realistic responses (e.g., MockResearchTool returns a JSON of trending products generated by an LLM or a randomized algorithm).
    *   They maintain internal state (e.g., MockShopify keeps a list of "created" products in memory).

**Required Changes:**
1.  **Smart Mocks**: Implement MockShopifyAdapter, MockResearchAdapter that behave like the real systems.
2.  **Stateful Simulation**: Mocks should share state where necessary (e.g., Inventory).

### D. Workflow Wiring (The Nervous System)

**Current State:**
*   Logic flow is hardcoded.

**Target State:**
*   Logic flow is defined in **workflows.yaml**.
    `yaml
    subscriptions:
      - event: "RESEARCH_REQUESTED"
        subscriber: "research_agent"
        action: "find_products"
    `

**Required Changes:**
1.  **Subscription Manager**: Registers subscriptions on the Event Bus at boot time.
2.  **Standardized Event Handlers**: Agents implement a common interface to receive events.

### E. Simulation vs. Live Mode (Orchestration)

**Current State:**
*   SimulationService drives the app procedurally.

**Target State:**
*   **Live Mode**: WebhookIngress receives real world events.
*   **Sim Mode**: SimulationOrchestrator injects **Random/Scripted Events**.
    *   It does NOT manage Agent workflows.
    *   It acts as the "Chaos Monkey" or "User Traffic Generator".
    *   Example: It emits TREND_DETECTED or ORDER_RECEIVED at random intervals to see how the Agents react.

**Required Changes:**
1.  **SimulationOrchestrator**: A service configured by scenario.yaml to emit events over time.
2.  **WebhookIngress**: A service that maps external webhooks to internal events.

---

## 3. Detailed Implementation Roadmap

This roadmap breaks down the refactor into small, verifiable chunks.

### Phase 0: Foundation & Documentation
*Goal: Establish the "Living Spec" to avoid constant code diving.*
*   [ ] **Task 0.1**: Create Documentation/ARCHITECTURE_REFERENCE.md. This file will map every YAML config option to the TypeScript class it instantiates.
*   [ ] **Task 0.2**: Create the directory structure for the new core (src/core/bootstrap, src/core/bus, src/core/mcp).

### Phase 1: The Skeleton (Configuration Engine)
*Goal: The app can boot up and read its own configuration.*
*   [ ] **Task 1.1**: Create the 5 YAML files with "Skeleton" content in config/.
*   [ ] **Task 1.2**: Implement YamlLoader to read and merge these files.
*   [ ] **Task 1.3**: Implement ServiceFactory (simple registry of class names to constructors).
*   [ ] **Task 1.4**: Implement Container (Dependency Injection).
*   [ ] **Task 1.5**: Create Bootstrapper class.
*   **Verification**: Create a script scripts/test-boot.ts that loads the config and prints the resolved configuration object.
*   **Alignment Check**: Verify ootstrap.yaml structure matches the Target Architecture diagram's "Config Layer".

### Phase 2: The Nervous System (Event Bus)
*Goal: We can publish and subscribe to events using the new infrastructure.*
*   [ ] **Task 2.1**: Define IEventBus interface.
*   [ ] **Task 2.2**: Implement PostgresEventBus (using pg or prisma).
*   [ ] **Task 2.3**: Update ServiceFactory to instantiate the bus defined in infrastructure.yaml.
*   **Verification**: Create scripts/test-bus.ts. Publish an event "TEST_EVENT" and ensure a subscriber receives it.
*   **Alignment Check**: Ensure the Bus implementation supports the "Event Bus" component in the diagram.

### Phase 3: The Body (MCP & Tools)
*Goal: Agents can call tools via a generic interface, swapping Real for Mock.*
*   [ ] **Task 3.1**: Implement McpClient (wrapper for both Internal classes and Stdio).
*   [ ] **Task 3.2**: Refactor ShopifyAdapter to implement IMcpTool.
*   [ ] **Task 3.3**: Create MockShopifyAdapter (Generative Mock).
*   [ ] **Task 3.4**: Update mcp.yaml to define both.
*   **Verification**: Create scripts/test-tool.ts. Load mcp.yaml, instantiate the tool, and call it. Verify Mock returns generated data.
*   **Alignment Check**: Verify mcp.yaml correctly maps to the "MCP Host" layer in the diagram.

### Phase 4: The Brain (Agents & Workflows)
*Goal: Agents are config-driven and react to events.*
*   [ ] **Task 4.1**: Refactor BaseAgent to accept 	ools and us in constructor.
*   [ ] **Task 4.2**: Implement WorkflowManager to read workflows.yaml and register subscriptions.
*   [ ] **Task 4.3**: Refactor CEOAgent to emit RESEARCH_REQUESTED instead of calling methods.
*   **Verification**: Run a "Dry Run" where CEOAgent emits an event, and we see it in the Postgres logs.
*   **Alignment Check**: Verify gents.yaml and workflows.yaml match the "Agent Layer" in the diagram.

### Phase 5: The Drivers (Sim & Live)
*Goal: The system runs autonomously.*
*   [ ] **Task 5.1**: Implement WebhookIngress (Express routes -> Event Bus).
*   [ ] **Task 5.2**: Implement SimulationOrchestrator (Scenario -> Event Bus).
*   [ ] **Task 5.3**: Update index.ts to use the Bootstrapper.
*   **Verification**: Run the full simulation.
*   **Alignment Check**: Compare the running system logs against the "Target Architecture" flow.
