# Gap Analysis: Modular, YAML-Driven Architecture

**Status:** âœ… Completed (v1.0)

This document outlines the transition from the initial hardcoded/monolithic state to the current fully modular, configuration-driven system.

## 1. The YAML Configuration Strategy

To answer "what can be spun up from YAML", the goal is **everything**. The code is a generic engine; the YAML defines the specific application instance.

**Key Principle: Architectural Symmetry**
The system structure is **identical** in both Simulation and Live modes.
*   **Live Mode**: Driven by Real Events (Webhooks) -> Processed by Agents -> Actions on Real APIs.
*   **Sim Mode**: Driven by Synthetic Events (Orchestrator) -> Processed by Agents -> Actions on Mock APIs (Generative).

We implemented a **5-File Configuration Structure**:

| File | Purpose | What it Controls |
| :--- | :--- | :--- |
| **1. bootstrap.yaml** | **Entry Point** | Environment mode (Live/Sim), Log levels, paths to other config files. |
| **2. infrastructure.yaml** | **Plumbing** | **Event Bus provider** (Postgres), Database connections, Server ports. |
| **3. mcp.yaml** | **Tools/IO** | **MCP Servers** (Stdio/SSE) and **Internal Adapters**. Defines *capabilities*. |
| **4. agents.yaml** | **Workers** | Which Agents to spawn, their System Prompts, Model settings, and assigned Tools (MCP Servers). |
| **5. workflows.yaml** | **Wiring** | Event Subscriptions. Who listens to what? (e.g., OrderPaid -> FulfillmentAgent). |

---

## 2. Detailed Gap Analysis

### A. Modular Bootstrapping (The Core Engine) - **STATUS: COMPLETED**

**Current State:**
*   `src/core/bootstrap/Container.ts` is the main entry point.
*   `src/core/bootstrap/ServiceFactory.ts` handles object creation.
*   `src/core/bootstrap/YamlLoader.ts` loads configuration.

**Target State:**
*   src/index.ts is minimal and mode-agnostic:
    ```typescript
    const config = YamlLoader.load('bootstrap.yaml');
    const container = new Container(config);
    container.boot();
    ```
*   The **Container** instantiates the exact same core classes for both Sim and Live.

**Required Changes:**
1.  **YamlLoader**: A utility to read and merge the 5 YAML files. (Done)
2.  **ServiceFactory**: A class that takes a string name and returns an instance. (Done)
3.  **DependencyContainer**: Holds the singletons (Bus, Adapters) and injects them into Agents. (Done)

### B. Infrastructure & Event Bus (Postgres-Backed) - **STATUS: COMPLETED**

**Current State:**
*   `PostgresAdapter` and `PostgresEventStore` are implemented.
*   `PersistencePort` and `EventBusPort` interfaces are defined.

**Target State:**
*   **PostgresEventBus** is the single source of truth for both Live and Simulation.
*   **infrastructure.yaml** example:
    ```yaml
    event_bus:
      type: "postgres"
      connection: ""
      table_name: "events"
    ```

**Required Changes:**
1.  **Interface IEventBus**: Standardize publish() and subscribe(). (Done)
2.  **Implementation**: Ensure PostgresEventBus is robust and can handle the load. (Done)
3.  **Factory Logic**: The Bootstrapper initializes the bus before any agents. (Done)

### C. MCP & Tools (Generative Mocks) - **STATUS: COMPLETED**

**Current State:**
*   `McpToolProvider` interface created.
*   All internal adapters (`Shopify`, `Ads`, `Trend`, `Competitor`, `Fulfilment`, `Email`, `Ai`) are wrapped with `McpToolProvider` implementations.
*   `mcp-server.ts` entry point created and functional.

**Target State:**
*   **Live Mode**: Adapters wrap real API calls (Shopify, Meta).
*   **Sim Mode**: Adapters are **Generative Mocks**.
    *   They do NOT just return static data.
    *   They generate realistic responses (e.g., MockResearchTool returns a JSON of trending products generated by an LLM or a randomized algorithm).
    *   They maintain internal state (e.g., MockShopify keeps a list of "created" products in memory).

**Required Changes:**
1.  **Smart Mocks**: Implement MockShopifyAdapter, MockResearchAdapter that behave like the real systems. (Done)
2.  **Stateful Simulation**: Mocks should share state where necessary (e.g., Inventory). (Done)
3.  **MCP Wrappers**: Wrap all adapters with `McpToolProvider` implementations. (Done)

### D. Workflow Wiring (The Nervous System) - **STATUS: COMPLETED**

**Current State:**
*   `WorkflowManager` implemented.
*   `workflows.yaml` is read at startup.
*   Agents are automatically subscribed to events based on configuration.
*   `BaseAgent` has a fallback `handleEvent` method.

**Target State:**
*   Logic flow is defined in **workflows.yaml**.
    ```yaml
    subscriptions:
      - event: "Sales.OrderPaid"
        subscriber: "OperationsAgent"
        action: "fulfill_order"
    ```

**Required Changes:**
1.  **Workflow Parser**: Read the YAML and register subscriptions on the Event Bus. (Done)
2.  **Agent Interface**: Ensure all agents have a standard `handleEvent(event)` method. (Done)
